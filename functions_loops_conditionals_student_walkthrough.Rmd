## Functions and Conditionals

### Conditionals

The basic syntax for an if statement goes like this:

```{r}
if (logical statement) {
  do something
} else {
  do something else
}
```

The logical statements should boil down to a boolean; for example:

```{r}
a <- 10

if (a <= 5) {
  print(a)
}else{
  print("its more than 5")
}
```

We can also add else if statements in the middle if we need more options.

```{r}
a <- 15

if (a <- 5) {
  print("small")
}else if (a > 5 & a <=10){
  print("medium")
}else if (a > 10) a == 7 {
  print("large")
}else{
  print("huge")
}
```

Neat! We can also nest conditionals just like we do in Python.

```{r}
a <- 5
if (a / 2 !=0) {
  if (a == 5){
    print("a is 5")
  }
}
    
```

Neat! Now, let's look at another core part of R programming - Loops!

### Loops

```{r}
for (value in 1:5) {
  # paste is a concatenation function
  print(paste(value, "is greater than", value - 1))
}
```

We can also do nifty stuff with our vectors, such as apply changes to specific indices of our data.

```{r}
a_vector <- c(1,1,1,1,1,1,1)

# change the first, third and 6th elements to the value 6

for (i in c(1,3,6)){
  a_vector[i] <- 6
}

a_vector
```

We can loop over more than just lists:

```{r}
mat <- matrix(1, nrow = 2, ncol = 2)

for (row in 1:2){
  for (col in 1:2){
    mat[row,col] <- 0
    print(mat)
  }
}
```

\
Like Python, we have while loops in R:

```{r}
b <- 0
while (b < 10) {
  # increase b by 2
  b <- b + 2 
  # print b
  print(b)
}
```

## Functions

When should we use functions?

```{r}
our_function <- function(optional_params){
  # do some stuff
}
```

An example:

```{r}
# start with a vector of temperatures
test_temp <- c(16.550540, 26.942005, 32.591088, 8.580116, 28.003873, 28.542391, 20.976820, 21.173577, 18.769735)

# then we want a function that converts from ccelcius to farenheit
c_to_f <-  function(dat){
  temp_fahr <-  dat*(9/5) + 32
  
  return(temp_fahr)
}

print(c_to_f(26))
```

This is all cool.. but it didn't do anything. We need to call the function!

```{r}
data_fahr <-  c_to_f(test_temp)
data_fahr
```

Notice that in the background here, we are looping over each item in the array, but we never write a for loop! Keep this in mind, since when you pass in a large data set, the changes made by functions aren't quite immediate - the computer does have to go over each item in your data set, and change them one at a time.

A shortcut of sorts is to use the `apply()` function, which operates very similarly to Python's `map()`. Note that `apply` syntax goes as follows: `apply(X, MARGIN, FUN)` where X is the data set to use, MARGIN is specification for rows or columns, and FUN is the function to apply.

```{r}
test_mat <- matrix(c(1,1,1,2,2,2), nrow <-  2)
# 1 is for rows 2 is for columns
apply(test_mat,2,sum)
```

It is common to use `mean`, `median`, `sum`, `min`, or `max` with `apply`, but we can also use our user-defined functions as well. Note that apply() only works with matrices.

```{r}
test_temp_mat <- matrix(c(16.550540, 26.942005, 32.591088, 8.580116, 28.003873, 28.542391, 20.976820, 21.173577, 18.769735), nrow = 2)

apply(test_temp_mat, 1, c_to_f)

```

### Homework

1.  Do 5 CodeWars problems in R. Share your solutions here:

    ```{r}
    #1 Given a non-negative integer, return an array / a list of the individual digits in order.

    digitize <- function(n){
      if (n == 0) {
        return(0)
      } 
      else {
        digits <- as.numeric(strsplit(as.character(n), '')[[1]])
        return(digits)
      }
    }

    results <- digitize(5678)
    print(results)

    #2 Consider integer numbers from 0 to n - 1 written down along the circle in such a way that the distance between any two neighbouring numbers is equal (note that 0 and n - 1 are neighbouring, too).Given n and firstNumber/first_number/first-number, find the number which is written in the radially opposite position to firstNumber

    circle_of_numbers <- function(n, first_number) {
      return((first_number + n / 2) %% n)
    }

    result <- circle_of_numbers(10, 2)

    #3 Create a function taking a positive integer between 1 and 3999 (both included) as its parameter and returning a string containing the Roman Numeral representation of that integer.

    solution <- function(n){
      if (n < 1 || n > 3999) {
        stop("Out of range, please enter a number between 1 and 3999.")
      }
      
      numerals <- c("M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I")
      values <- c(1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1)
      
      result <- ""
      for (i in 1:length(numerals)) {
        while (n >= values[i]) {
          result <- paste0(result, numerals[i])
          n <- n - values[i]
        }
      }
      return(result)
    }

    answer <- solution(2020)
    print(answer)

    #4Your task is to make a function that can take any non-negative integer as an argument and return it with its digits in descending order. Essentially, rearrange the digits to create the highest possible number.

    descending_order <- function(num) {
      if (number < 0) {
        stop("Number should be non negative.")
      }
      digits <- strsplit(as.character(num), '')[[1]]

      sorted_digits <- sort(digits, decreasing = TRUE)

      result <- as.numeric(paste0(sorted_digits, collapse = ''))

      return(result)
    }

    the_answer <- descending_order(3579)
    print(the_answer)

    #5 Implement a function that accepts 3 integer values a, b, c. The function should return true if a triangle can be built with the sides of given length and false in any other case.

    is_triangle <- function(a, b, c){
      if (a <= 0 || b <= 0 || c <= 0) {
        return(FALSE)
      }
      if (a + b > c && a + c > b && b + c > a) {
        return(TRUE)
      }
      else {
        return(FALSE)
      }
    }

    result <- is_triangle(2,2,2)
    print(result)


    ```

2.  Create a function that checks an input of type `int` and returns fizz if the number is a multiple of 3, buzz if the number is a multiple of 5, and fizzbuzz if the number is a multiple of 3 and 5.

    ```{r}
    fizzbuzz <- function(number) {
      if (number %% 3 == 0 && number %% 5== 0) {
        return("fizzbuzz")
      }
      else if (number %% 3 == 0) {
        return("fizz")
      }
      else if (numbeer %% 5 ==0) {
        return("buzz")
      }
      else {
        return(number)
      }
    }

    check_num <- fizzbuzz(9)
    print(check_num)
    ```

3.  **Mario Challenge:** In the classic Super Mario games, Mario ends each level by ascending a flight of stairs and leaping off the top to arrive at the castle at the end. (See [here](https://youtu.be/-avspZlbOWU?t=55) for details). We can imagine that each of the bricks of the stairs is a character X. Create a function that prints out a set of stairs. For example:

    If the function is called marioStairs() and we pass in the value 4, we would expect to see stairs with a length of 4 and a height of 4:

    X

    XX

    XXX

    XXXX

    ```{r}
    marioStairs <- function(height) {
      for (i in 1:height) {
        cat(paste(rep("X", i), collapse = ""), "\n")
      }
    }

    marioStairs(5)
    ```
